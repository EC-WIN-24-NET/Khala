import { type NextRequest, NextResponse } from "next/server";
import type { FullApiResponse } from "@/app/api/types";

// The HandlerConfig is now extended with an optional revalidate property and a generic for dataMapper return type
export interface HandlerConfig<T, MappedData = T> {
	endpointPath: string;
	allowedMethod: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
	/**
	 * Optional: The cache lifetime in seconds for the server-side fetch request.
	 * This enables Incremental Static Regeneration (ISR) for your API route.
	 */
	revalidate?: number;
	dataMapper?: (data: T) => MappedData;
}

/**
 * This Code block was 100% Generated by Google Pro Gemeni,
 * Changed from my original code, becouse Axios could not work with revalidate so we (server side)
 * can use swr together with NextJS (server side)
 * A generic handler for API requests in a Next.js application.
 * It proxies requests to a configured APIM endpoint, handles caching,
 * data transformation, and error responses.
 *
 * @template T The expected type of the raw data from the API's `value` field.
 * @template MappedData The type of the data after being processed by the optional `dataMapper`. Defaults to `T`.
 *
 * @param {NextRequest} req The incoming Next.js request object.
 * @param {HandlerConfig<T, MappedData>} config Configuration for the API handler, including:
 * - `allowedMethod`: The HTTP method allowed for this endpoint (e.g., "GET", "POST").
 * - `endpointPath`: The specific path for the target APIM endpoint (e.g., "/users").
 * - `revalidate`: The cache revalidation time in seconds for Next.js `fetch`.
 * - `dataMapper` (optional): A function to transform the raw API response data (`T`) into `MappedData`.
 *
 * @returns {Promise<NextResponse>} A Next.js response object.
 * - On success, returns a JSON response with the (potentially mapped) data and status 200.
 * - On method not allowed, returns status 405.
 * - On missing server configuration (APIM key/endpoint), returns status 500.
 * - On API errors (from APIM or non-ok HTTP status), returns the error message and status code from APIM or the response.
 * - If no data is found or the API response structure is unexpected, returns status 404.
 * - On unhandled server errors during processing, returns status 500.
 *
 * @throws Will not directly throw but catches errors and returns them as `NextResponse` objects.
 *
 * @example
 * ```typescript
 * // In your pages/api/users.ts or app/api/users/route.ts
 * import { NextRequest, NextResponse } from 'next/server';
 * import { genericApiHandler } from './genericApiHandler'; // Adjust path as needed
 *
 * interface User {
 * id: string;
 * name: string;
 * }
 *
 * interface TransformedUser {
 * userId: string;
 * fullName: string;
 * }
 *
 * const userHandlerConfig: HandlerConfig<User, TransformedUser> = {
 * allowedMethod: 'GET',
 * endpointPath: '/users',
 * revalidate: 60, // Revalidate every 60 seconds
 * dataMapper: (user) => ({
 * userId: user.id,
 * fullName: user.name,
 * }),
 * };
 *
 * export async function GET(req: NextRequest) {
 * return genericApiHandler<User, TransformedUser>(req, userHandlerConfig);
 * }
 * ```
 */

// A simple function that creates a delay using a Promise.
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export async function genericApiHandler<T, MappedData = T>(
	req: NextRequest,
	config: HandlerConfig<T, MappedData>,
): Promise<NextResponse> {
	// 1. --------- Method Guard Clause ---------
	if (req.method !== config.allowedMethod) {
		// A "Guard Clause" is an early exit from a function if a condition isn't met.
		// Here, we check if the incoming request's HTTP method (like GET or POST) is the one we allow.
		// If not, we stop immediately and send a 405 "Method Not Allowed" response.
		return NextResponse.json(
			{ message: `Method ${req.method} Not Allowed` },
			{ status: 405, headers: { Allow: config.allowedMethod } },
		);
	}

	// 2. --------- Configuration Guard Clause ---------
	// We check that our server is properly configured with the necessary secrets.
	// These `process.env` variables are pulled from your `.env.local` file.
	const apimSubscriptionKey = process.env.APIM_KEY;
	const apimEndpoint = process.env.APIM_BASE_ENDPOINT;

	// If these secrets are missing, the API proxy can't work, so we exit with a server error.
	if (!apimSubscriptionKey || !apimEndpoint) {
		console.error("API configuration missing in environment variables.");
		return NextResponse.json(
			{ message: "Server configuration error for API." },
			{ status: 500 },
		);
	}

	// We build the full URL to the external API we want to call.
	const targetUrl = `${apimEndpoint}${config.endpointPath}`;

	try {
		// 3. --------- The Fetch Request ---------
		await sleep(1500);

		// We're using the native `fetch` API, which is built into modern JavaScript environments.
		// Next.js extends `fetch` with special powers, like server-side caching. We use that instead of Axios
		const response = await fetch(targetUrl, {
			method: req.method,
			headers: {
				// We securely add our secret API key to the request headers.
				// This is safe because this code only ever runs on the server, not in the user's browser.
				"Ocp-Apim-Subscription-Key": apimSubscriptionKey,
				"Content-Type": "application/json",
			},
			// This `next` object is the special part that Next.js adds to `fetch`.
			// `revalidate` tells Next.js to cache the response on the server for a number of seconds.
			// This reduces calls to the external API, saving money and improving speed.
			next: {
				revalidate: config.revalidate,
			},
		});

		// 4. --------- Robust, Two-Step Error Handling ---------

		// Step 4a: Handle fundamental HTTP errors first.
		// `response.ok` is a boolean that is `true` only for successful HTTP statuses (like 200-299).
		// We check for failure here before trying to read the response body.
		if (!response.ok) {
			// An error response might contain details in a JSON body, but it might not (e.g., a 502 error could be HTML).
			// We safely try to parse JSON, but if it fails, the `.catch()` provides a graceful fallback message.
			const errorPayload = await response.json().catch(() => ({
				message: `Request failed with status: ${response.status} ${response.statusText}`,
			}));

			// We log the error for debugging purposes.
			const errorMessage =
				errorPayload?.message || "An unknown API error occurred";
			console.error(`APIM HTTP Error (${response.status}):`, errorMessage);

			// We return a JSON error response with the original status code from the failed external API call.
			return NextResponse.json(
				{ message: errorMessage },
				{ status: response.status },
			);
		}

		// If we reach here, the response is OK (2xx status). Now we can safely parse the body.
		const result = (await response.json()) as FullApiResponse<T>;

		// Step 4b: Handle application-level errors reported inside the successful JSON response.
		// Sometimes an API returns a 200 OK status but includes an error message in the data.
		// (e.g., `{ "value": null, "error": { "message": "Invalid ID" } }`)
		if (result?.error?.message) {
			const statusCode = result.statusCode || 400;
			console.error(
				`APIM Application Error (${statusCode}):`,
				result.error.message,
			);
			return NextResponse.json(
				{ message: result.error.message },
				{ status: statusCode },
			);
		}

		// 5. --------- Success Path ---------

		// If everything has gone well, we check that the data we expect is actually there.
		// We check for `result.value !== undefined` to handle cases where the value might be `null` on purpose.
		if (result && result.value !== undefined) {
			// A "data mapper" is a function that lets us transform the data before sending it to the client.
			// This is useful for renaming keys, simplifying objects, or filtering data.
			const dataToReturn = config.dataMapper
				? config.dataMapper(result.value)
				: result.value;

			// We send the final data to the client with a 200 OK status.
			return NextResponse.json(dataToReturn, { status: 200 });
		}

		// 6. --------- Fallback for Unexpected Structure ---------
		// This handles the case where the API gave a 200 OK response, but the JSON structure
		// was not what we expected (e.g., the `value` field was missing).
		console.warn("Unexpected API response structure or no data:", result);
		return NextResponse.json(
			{ message: "No data found or unexpected response format." },
			{ status: 404 },
		);
	} catch (error) {
		// 7. --------- Catch-All for Unhandled Errors ---------
		// This `catch` block is a safety net. It will catch errors if the `fetch` call itself
		// fails (e.g., a network problem, DNS issue) or if any other unexpected exception occurs.
		console.error(`Unhandled error in ${config.endpointPath}:`, error);
		const errorMessage =
			error instanceof Error
				? error.message
				: "An unknown server error occurred.";
		// We return a generic 500 Internal Server Error response.
		return NextResponse.json(
			{ message: "Server error.", details: errorMessage },
			{ status: 500 },
		);
	}
}
