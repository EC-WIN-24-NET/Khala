import { type NextRequest, NextResponse } from "next/server";
import type { FullApiResponse } from "@/app/api/types";

// The HandlerConfig is now extended with an optional revalidate property and a generic for dataMapper return type
export interface HandlerConfig<T, MappedData = T> {
	endpointPath: string;
	allowedMethod: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
	/**
	 * Optional: The cache lifetime in seconds for the server-side fetch request.
	 * This enables Incremental Static Regeneration (ISR) for your API route.
	 */
	revalidate?: number;
	dataMapper?: (data: T) => MappedData;
}

// A simple function that creates a delay using a Promise.
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Function to handle retrying fetch requests in case of 403 Forbidden errors
// Becouse of how APIM handles rate limiting and SAS tokens expiration
async function fetchWithRetry(
	getUrl: () => Promise<string>,
	options: RequestInit,
	maxRetries = 1,
	retryCount = 0,
): Promise<Response> {
	const currentUrl = await getUrl();
	const response = await fetch(currentUrl, options);

	// If the response is 403 and we haven't reached the max retries, retry
	// If we get an 403, we wait for 15 seconds and retry so the SAS token is refreshed
	// This regarding using Azure Blob Storage
	if (response.status === 403 && retryCount < maxRetries) {
		console.warn(
			`Received 403 from ${currentUrl}, attempting retry ${retryCount + 1} of ${maxRetries}...`,
		);
		// Optional: wait for a short period before retrying
		await new Promise((resolve) => setTimeout(resolve, 3000));
		return fetchWithRetry(getUrl, options, maxRetries, retryCount + 1);
	}

	return response;
}

/**
 * This Code block was 100% Generated by Google Pro Gemini,
 * Changed from my original code, because Axios could not work with revalidate so we (server side)
 * can use swr together with NextJS (server side)
 *
 * A generic handler for API requests that proxies requests to an Azure API Management (APIM) instance.
 * It handles method validation, configuration checks, request body processing,
 * API calls with retry logic (via `fetchWithRetry`), and various error scenarios.
 *
 * @template T The expected type of the `value` field in the successful API response from the external service.
 * @template MappedData The type of the data after being transformed by the optional `dataMapper`. Defaults to `T`.
 *
 * @param {NextRequest} req The incoming Next.js request object.
 * @param {HandlerConfig<T, MappedData>} config Configuration for the API handler.
 * @param {string} config.allowedMethod The HTTP method allowed for this endpoint (e.g., "GET", "POST").
 * @param {string} config.endpointPath The specific path for the APIM endpoint (e.g., "/users").
 * @param {number} [config.revalidate] Optional cache revalidation time in seconds for Next.js `fetch`.
 * @param {(data: T) => MappedData} [config.dataMapper] Optional function to transform the successful API response data.
 *
 * @returns {Promise<NextResponse>} A Next.js response object.
 * This can be a JSON response with the (optionally mapped) data on success,
 * or a JSON response with an error message and appropriate status code on failure.
 *
 * @example
 * ```typescript
 * // In your app/api/users/route.ts
 * import { NextRequest, NextResponse } from 'next/server';
 * import { genericApiHandler } from '@/app/api/genericApiHandler';
 *
 * interface User {
 *   id: string;
 *   name: string;
 * }
 *
 * interface SimpleUser {
 *   identifier: string;
 *   fullName: string;
 * }
 *
 * export async function GET(req: NextRequest) {
 *   return genericApiHandler<User[], SimpleUser[]>(req, {
 *     allowedMethod: "GET",
 *     endpointPath: "/users",
 *     revalidate: 60, // Revalidate every 60 seconds
 *     dataMapper: (users) => users.map(user => ({
 *       identifier: user.id,
 *       fullName: user.name,
 *     })),
 *   });
 * }
 *
 * export async function POST(req: NextRequest) {
 *   return genericApiHandler<User>(req, {
 *     allowedMethod: "POST",
 *     endpointPath: "/users",
 *     // No dataMapper needed if the response structure is fine as is
 *   });
 * }
 * ```
 *
 * @throws Will not directly throw errors but rather catches them and returns a `NextResponse`
 * with an appropriate error status code and message. Potential error responses include:
 * - 400 Bad Request: If the request body for POST/PUT/PATCH is invalid JSON.
 * - 405 Method Not Allowed: If the request method does not match `config.allowedMethod`.
 * - 404 Not Found: If the API returns a 200 OK but the expected `value` field is missing.
 * - 500 Internal Server Error: For missing server configuration (APIM keys/endpoint) or
 *   any unhandled exceptions during the process (e.g., network errors, `fetch` failures).
 * - Other status codes (e.g., 401, 403, 502) may be proxied from the APIM if it returns an error.
 */
export async function genericApiHandler<T, MappedData = T>(
	req: NextRequest,
	config: HandlerConfig<T, MappedData>,
): Promise<NextResponse> {
	// 1. --------- Method Guard Clause ---------
	if (req.method !== config.allowedMethod) {
		// A "Guard Clause" is an early exit from a function if a condition isn't met.
		// Here, we check if the incoming request's HTTP method (like GET or POST) is the one we allow.
		// If not, we stop immediately and send a 405 "Method Not Allowed" response.
		return NextResponse.json(
			{ message: `Method ${req.method} Not Allowed` },
			{ status: 405, headers: { Allow: config.allowedMethod } },
		);
	}

	// 2. --------- Configuration Guard Clause ---------
	// We check that our server is properly configured with the necessary secrets.
	// These `process.env` variables are pulled from your `.env.local` file.
	const apimSubscriptionKey = process.env.APIM_KEY;
	const apimEndpoint = process.env.APIM_BASE_ENDPOINT;

	// If these secrets are missing, the API proxy can't work, so we exit with a server error.
	if (!apimSubscriptionKey || !apimEndpoint) {
		console.error("API configuration missing in environment variables.");
		return NextResponse.json(
			{ message: "Server configuration error for API." },
			{ status: 500 },
		);
	}

	// We build the full URL to the external API we want to call.
	const targetUrl = `${apimEndpoint}${config.endpointPath}`;

	try {
		await sleep(1500);

		const fetchOptions: RequestInit = {
			// Defined options for fetch
			method: req.method,
			headers: {
				"Ocp-Apim-Subscription-Key": apimSubscriptionKey,
				"Content-Type": "application/json",
			},
			next: {
				revalidate: config.revalidate,
			},
		};

		// 3. --------- Handle Request Body ---------

		// If the method is POST, PUT, or PATCH, read the body from the incoming request
		// and add it to the fetch options.
		if (
			req.method === "POST" ||
			req.method === "PUT" ||
			req.method === "PATCH"
		) {
			try {
				// Student Note: `req.json()` is a method provided by Next.js to parse the request body as JSON.
				const body = await req.json(); // Assumes JSON body
				fetchOptions.body = JSON.stringify(body);
			} catch (parseError) {
				// Student Note: If the request body is not valid JSON, we catch the error and return a 400 Bad Request response.
				console.error("Error parsing request body:", parseError);
				return NextResponse.json(
					{ message: "Invalid request body." },
					{ status: 400 },
				);
			}
		}

		// 4. --------- Fetch from APIM ---------
		const response = await fetchWithRetry(
			() => Promise.resolve(targetUrl),
			fetchOptions, // Use the constructed fetchOptions
		);

		// 4. --------- Handle API Response ---------

		// Step 4a: Handle fundamental HTTP errors first.
		// `response.ok` is a boolean that is `true` only for successful HTTP statuses (like 200-299).
		// We check for failure here before trying to read the response body.
		if (!response.ok) {
			// An error response might contain details in a JSON body, but it might not (e.g., a 502 error could be HTML).
			// We safely try to parse JSON, but if it fails, the `.catch()` provides a graceful fallback message.
			const errorPayload = await response.json().catch(() => ({
				message: `Request failed with status: ${response.status} ${response.statusText}`,
			}));

			// We log the error for debugging purposes.
			const errorMessage =
				errorPayload?.message || "An unknown API error occurred";
			console.error(`APIM HTTP Error (${response.status}):`, errorMessage);

			// We return a JSON error response with the original status code from the failed external API call.
			return NextResponse.json(
				{ message: errorMessage },
				{ status: response.status },
			);
		}

		// If we reach here, the response is OK (2xx status). Now we can safely parse the body.
		const result = (await response.json()) as FullApiResponse<T>;

		// Step 4b: Handle application-level errors reported inside the successful JSON response.
		// Sometimes an API returns a 200 OK status but includes an error message in the data.
		// (e.g., `{ "value": null, "error": { "message": "Invalid ID" } }`)
		if (result?.error?.message) {
			const statusCode = result.statusCode || 400;
			console.error(
				`APIM Application Error (${statusCode}):`,
				result.error.message,
			);
			return NextResponse.json(
				{ message: result.error.message },
				{ status: statusCode },
			);
		}

		// 5. --------- Success Path ---------

		// If everything has gone well, we check that the data we expect is actually there.
		// We check for `result.value !== undefined` to handle cases where the value might be `null` on purpose.
		if (result && result.value !== undefined) {
			// A "data mapper" is a function that lets us transform the data before sending it to the client.
			// This is useful for renaming keys, simplifying objects, or filtering data.
			const dataToReturn = config.dataMapper
				? config.dataMapper(result.value)
				: result.value;

			// We send the final data to the client with a 200 OK status.
			return NextResponse.json(dataToReturn, { status: 200 });
		}

		// 6. --------- Fallback for Unexpected Structure ---------
		// This handles the case where the API gave a 200 OK response, but the JSON structure
		// was not what we expected (e.g., the `value` field was missing).
		console.warn("Unexpected API response structure or no data:", result);
		return NextResponse.json(
			{ message: "No data found or unexpected response format." },
			{ status: 404 },
		);
	} catch (error) {
		// 7. --------- Catch-All for Unhandled Errors ---------
		// This `catch` block is a safety net. It will catch errors if the `fetch` call itself
		// fails (e.g., a network problem, DNS issue) or if any other unexpected exception occurs.
		console.error(`Unhandled error in ${config.endpointPath}:`, error);
		const errorMessage =
			error instanceof Error
				? error.message
				: "An unknown server error occurred.";
		// We return a generic 500 Internal Server Error response.
		return NextResponse.json(
			{ message: "Server error.", details: errorMessage },
			{ status: 500 },
		);
	}
}
